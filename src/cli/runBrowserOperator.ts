import path from "node:path";
import { pathToFileURL } from "node:url";

type BuildPlanResult = { plan: unknown; forwardedCommand: string };

function isRecord(v: unknown): v is Record<string, unknown> {
  return !!v && typeof v === "object" && !Array.isArray(v);
}

function tryParseJsonArgTail(text: string): any {
  const trimmed = String(text ?? "").trim();
  const first = trimmed.indexOf("{");
  if (first === -1) return null;
  const candidate = trimmed.slice(first);
  try {
    return JSON.parse(candidate);
  } catch {
    return null;
  }
}

function extractJsonFromText(text: string): unknown {
  const trimmed = String(text ?? "").trim();
  if (!trimmed) return {};

  try {
    return JSON.parse(trimmed);
  } catch {
    // continue
  }

  const firstObj = trimmed.indexOf("{");
  const lastObj = trimmed.lastIndexOf("}");
  if (firstObj !== -1 && lastObj !== -1 && lastObj > firstObj) {
    const candidate = trimmed.slice(firstObj, lastObj + 1);
    try {
      return JSON.parse(candidate);
    } catch {
      // continue
    }
  }

  throw new Error("/browser operator args must be valid JSON");
}

function sanitizeExecutionIdPart(part: string) {
  return String(part ?? "").replace(/[^a-zA-Z0-9_-]/g, "-").slice(0, 80);
}

function parseBrowserOperatorCommand(command: string): { target: string; argsText: string } | null {
  const trimmed = command.trim();
  if (!/^\/browser\s+operator\b/i.test(trimmed)) return null;

  // Form 1: /browser operator <target> <json_args>
  const m = trimmed.match(/^\/browser\s+operator\s+(\S+)(?:\s+([\s\S]+))?$/i);
  if (m?.[1]) {
    const target = String(m[1]).trim();
    const argsText = typeof m[2] === "string" && m[2].trim() ? m[2].trim() : "{}";
    return { target, argsText };
  }

  // Form 2: /browser operator {"target":"...","actions":[...]}
  const payload = tryParseJsonArgTail(trimmed);
  const target = typeof payload?.target === "string" ? payload.target.trim() : "";
  if (!target) return null;
  return { target, argsText: JSON.stringify(payload) };
}

/**
 * Local read-only fast-path: governed browser operator.
 * Must NOT require planner/validator webhooks.
 */
export function tryBuildBrowserOperatorPlan(command: string, threadId: string): BuildPlanResult | null {
  const browserOp = parseBrowserOperatorCommand(command);
  if (!browserOp) return null;

  const rawTarget = browserOp.target;
  const targetLooksLikeUrl = /^[a-zA-Z][a-zA-Z0-9+.-]*:\/\//.test(rawTarget) || rawTarget.startsWith("file:");
  const url = targetLooksLikeUrl
    ? rawTarget
    : pathToFileURL(path.resolve(process.cwd(), rawTarget)).toString();

  const parsedArgs = extractJsonFromText(browserOp.argsText);
  const payload = isRecord(parsedArgs) ? parsedArgs : {};
  if (!("actions" in payload)) {
    throw new Error("/browser operator args must include an 'actions' array");
  }

  const execution_id = `tier_browser_operator_${sanitizeExecutionIdPart(rawTarget)}_${Date.now()}`;
  const plan = {
    kind: "ExecutionPlan",
    execution_id,
    threadId,
    dry_run: false,
    goal: `Browser operator: ${rawTarget}`,
    agent_versions: { validator: "1.2.0", planner: "1.1.3" },
    assumptions: ["Generated by local CLI fast-path"],
    required_secrets: [],
    steps: [
      {
        step_id: "browser-operator",
        action: "browser.operator",
        adapter: "BrowserOperatorAdapter",
        method: "GET",
        read_only: true,
        url,
        payload,
        expects: { http_status: 200 },
        idempotency_key: null,
      },
    ],
  };

  return { plan, forwardedCommand: command };
}
