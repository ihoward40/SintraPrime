import fs from "node:fs";
import path from "node:path";

import { simulatePolicy } from "../policy/simulatePolicy.js";
import { extractScoreFeatures } from "../policy/extractScoreFeatures.js";
import { scorePolicy } from "../policy/scorePolicy.js";
import { loadAgentRegistry, findAgentsProvidingCapability } from "../agents/agentRegistry.js";
import { nowIso as fixedNowIso } from "../utils/clock.js";
import { enforceCliCredits } from "../credits/enforceCliCredits.js";

function isRecord(v: unknown): v is Record<string, unknown> {
  return !!v && typeof v === "object" && !Array.isArray(v);
}

function getArgCommand() {
  const raw = process.argv.slice(2).join(" ").trim();
  if (!raw) throw new Error("Missing command argument");
  return raw;
}

function nowIso() {
  return new Date().toISOString();
}

type JobCard = {
  job_id: string;
  command: string;
  confidence: { score: number; band: string; action: string };
  regression: { regressed: boolean; requires_ack?: boolean; acknowledged?: boolean; severity?: string };
  policy_state: { allowed: boolean; reason: string };
  autonomy_mode: string;
  last_run: { status: string; exit_code: number | null; at: string | null } | null;
  rank: number;
};

function readJsonSafe(p: string): unknown | null {
  try {
    return JSON.parse(fs.readFileSync(p, "utf8"));
  } catch {
    return null;
  }
}

function listConfidenceChecks(): Array<{ execution_id: string; data: any }> {
  const dir = path.join(process.cwd(), "runs", "confidence-checks");
  if (!fs.existsSync(dir)) return [];
  const files = fs.readdirSync(dir).filter((f) => f.endsWith(".json"));
  const out: Array<{ execution_id: string; data: any }> = [];
  for (const f of files) {
    const execution_id = f.replace(/\.json$/i, "");
    const full = path.join(dir, f);
    const data = readJsonSafe(full);
    if (data && typeof data === "object") out.push({ execution_id, data });
  }
  return out;
}

function listApprovalsAwaiting(): Array<{ execution_id: string; created_at: string | null; plan_goal: string | null }> {
  const dir = path.join(process.cwd(), "runs", "approvals");
  if (!fs.existsSync(dir)) return [];
  const files = fs.readdirSync(dir).filter((f) => f.endsWith(".json"));
  const out: Array<{ execution_id: string; created_at: string | null; plan_goal: string | null }> = [];
  for (const f of files) {
    const full = path.join(dir, f);
    const data = readJsonSafe(full);
    if (!isRecord(data)) continue;
    const status = typeof data.status === "string" ? data.status : null;
    if (status !== "awaiting_approval") continue;
    const execution_id = typeof data.execution_id === "string" ? data.execution_id : f.replace(/\.json$/i, "");
    const created_at = typeof data.created_at === "string" ? data.created_at : null;
    const plan = (data as any).plan;
    const plan_goal = isRecord(plan) && typeof plan.goal === "string" ? plan.goal : null;
    out.push({ execution_id, created_at, plan_goal });
  }
  return out;
}

function listJobsRegistry(): Array<{ job_id: string; command: string; mode: string }> {
  const p = path.join(process.cwd(), "jobs", "registry.json");
  if (!fs.existsSync(p)) return [];
  const raw = readJsonSafe(p);
  if (!Array.isArray(raw)) return [];
  return raw
    .map((x) => {
      if (!isRecord(x)) return null;
      const job_id = typeof x.job_id === "string" ? x.job_id : null;
      const command = typeof x.command === "string" ? x.command : null;
      const mode = typeof x.mode === "string" ? x.mode : "OFF";
      if (!job_id || !command) return null;
      return { job_id, command, mode };
    })
    .filter(Boolean) as any;
}

function resolveCapabilityProviders(required: string[]) {
  const unresolved: string[] = [];
  if (!required.length) return { capabilities_resolved: true, unresolved };
  const registry = loadAgentRegistry();
  for (const cap of required) {
    const matches = findAgentsProvidingCapability(registry, cap);
    if (!matches.length) unresolved.push(cap);
  }
  return { capabilities_resolved: unresolved.length === 0, unresolved };
}

// Minimal deterministic plan builders (same contract as /policy score)
function buildPlanForCommand(inner: string, threadId: string, baseUrl: string): any {
  const trimmed = String(inner ?? "").trim();

  const mDb = trimmed.match(/^\/notion\s+(?:db|database)\s+(\S+)\s*$/i);
  if (mDb) {
    const dbId = String(mDb[1] ?? "").trim();
    return {
      kind: "ExecutionPlan",
      execution_id: "exec_operator_db_001",
      threadId,
      dry_run: false,
      goal: `Read Notion database ${dbId}`,
      required_capabilities: ["notion.read.database"],
      agent_versions: { validator: "1.2.0", planner: "1.1.3" },
      assumptions: ["Generated by operator queue"],
      required_secrets: [],
      steps: [
        {
          step_id: "read-database",
          action: "notion.read.database",
          adapter: "NotionAdapter",
          method: "GET",
          read_only: true,
          url: `${baseUrl}/notion/database/${encodeURIComponent(dbId)}`,
          headers: { "Cache-Control": "no-store" },
          expects: { http_status: [200], json_paths_present: ["properties", "id"] },
          idempotency_key: null,
        },
      ],
    };
  }

  const mSet = trimmed.match(/^\/notion\s+set\s+(\S+)\s+([^=\s]+)=(.+)$/i);
  if (mSet) {
    const pageId = String(mSet[1] ?? "").trim();
    const prop = String(mSet[2] ?? "").trim();
    const value = String(mSet[3] ?? "").trim();
    return {
      kind: "ExecutionPlan",
      execution_id: "exec_operator_set_001",
      threadId,
      dry_run: false,
      goal: `Set Notion page property ${prop} on ${pageId}`,
      required_capabilities: ["notion.write.page_property"],
      agent_versions: { validator: "1.2.0", planner: "1.1.3" },
      assumptions: ["Generated by operator queue"],
      required_secrets: [],
      steps: [
        {
          step_id: "write-page-property",
          action: "notion.write.page_property",
          adapter: "NotionAdapter",
          method: "PATCH",
          read_only: false,
          url: `${baseUrl}/notion/page/${encodeURIComponent(pageId)}`,
          headers: { "Cache-Control": "no-store" },
          payload: { properties: { [prop]: value } },
          expects: { http_status: [200], json_paths_present: ["updated"] },
          idempotency_key: null,
        },
      ],
    };
  }

  // /template run is supported by reading templates/registry.json (read-only)
  const mt = trimmed.match(/^\/template\s+run\s+(\S+)\s+([\s\S]+)$/i);
  if (mt) {
    const name = mt[1]!;
    const argsText = mt[2]!;
    const regPath = path.join(process.cwd(), "templates", "registry.json");
    if (!fs.existsSync(regPath)) throw new Error("Missing templates/registry.json");
    const registry = JSON.parse(fs.readFileSync(regPath, "utf8"));
    const tpl = registry?.templates?.[name]?.plan;
    if (!tpl) throw new Error(`Unknown template: ${name}`);
    const args = JSON.parse(argsText);

    // Naive var replace on {{key}} in strings (matches existing behavior enough for smoke)
    const substitute = (v: any): any => {
      if (v === null || v === undefined) return v;
      if (typeof v === "string") {
        return v.replace(/\{\{([a-zA-Z0-9_]+)\}\}/g, (_m, key) => {
          if (!(key in args)) throw new Error(`Missing template arg: ${key}`);
          return String(args[key]);
        });
      }
      if (Array.isArray(v)) return v.map(substitute);
      if (typeof v === "object") {
        const out: any = {};
        for (const [k, vv] of Object.entries(v)) out[k] = substitute(vv);
        return out;
      }
      return v;
    };

    const plan = substitute(tpl);
    if (!isRecord(plan) || plan.kind !== "ExecutionPlan") throw new Error("Template plan must be kind=ExecutionPlan");
    (plan as any).threadId = threadId;
    if (!(plan as any).execution_id) (plan as any).execution_id = "exec_operator_template_001";
    return plan;
  }

  throw new Error("/operator queue cannot build a plan for command");
}

function computeGroup(card: JobCard): number {
  const reg = card.regression;
  if (reg.regressed && reg.requires_ack && !reg.acknowledged) return 1;
  if (card.policy_state.reason === "APPROVAL_REQUIRED") return 2;
  if (card.confidence.action === "AUTO_RUN" && card.policy_state.allowed) return 3;
  if (card.autonomy_mode === "PROPOSE_ONLY_AUTONOMY") return 4;
  if (!card.policy_state.allowed) return 5;
  if (card.last_run && card.last_run.status === "success") return 6;
  return 6;
}

function rankJobs(jobs: JobCard[]): JobCard[] {
  const withMeta = jobs.map((j) => {
    const group = computeGroup(j);
    const waitingAt = j.last_run?.at ? new Date(j.last_run.at).getTime() : Number.POSITIVE_INFINITY;
    const t = Number.isFinite(waitingAt) ? waitingAt : Number.POSITIVE_INFINITY;
    return { j, group, t };
  });

  withMeta.sort((a, b) => {
    if (a.group !== b.group) return a.group - b.group;
    if (b.j.confidence.score !== a.j.confidence.score) return b.j.confidence.score - a.j.confidence.score;
    if (a.t !== b.t) return a.t - b.t;
    return a.j.job_id.localeCompare(b.j.job_id);
  });

  return withMeta.map((x, idx) => ({ ...x.j, rank: idx + 1 }));
}

function policyReasonFromSim(sim: any): { allowed: boolean; reason: string } {
  const decision = String(sim?.decision ?? "");
  if (decision === "ALLOWED") return { allowed: true, reason: "ALLOWED" };
  if (decision === "APPROVAL_REQUIRED") return { allowed: false, reason: "APPROVAL_REQUIRED" };
  return { allowed: false, reason: "DENIED" };
}

function jobCardFromConfidenceCheck(item: { execution_id: string; data: any }): JobCard | null {
  const d = item.data;
  if (!isRecord(d)) return null;
  const kind = typeof d.kind === "string" ? d.kind : null;
  if (kind !== "ConfidenceRegressionCheck") return null;

  const cmd = typeof (d as any).command === "string" ? (d as any).command : null;
  const current = (d as any).current;
  const regression = (d as any).regression;

  if (!cmd || !isRecord(current) || !isRecord(regression)) return null;

  const confidence = {
    score: typeof current.score === "number" ? current.score : 0,
    band: typeof current.band === "string" ? current.band : "LOW",
    action: typeof current.action === "string" ? current.action : "HUMAN_REVIEW_REQUIRED",
  };

  const regressed = Boolean((regression as any).regressed);
  const requires_ack = Boolean((regression as any).requires_ack);
  const acknowledged = Boolean((regression as any).acknowledged);
  const severity = typeof (regression as any).severity === "string" ? (regression as any).severity : undefined;

  const autonomy_mode = typeof (d as any).autonomy_mode === "string" ? (d as any).autonomy_mode : "OFF";

  const policy_reason = typeof (d as any).policy_state_reason === "string" ? (d as any).policy_state_reason : "HUMAN_REVIEW_REQUIRED";
  const policy_allowed = Boolean((d as any).policy_state_allowed);

  return {
    job_id: `confidence_${item.execution_id}`,
    command: cmd,
    confidence,
    regression: { regressed, requires_ack, acknowledged, severity },
    policy_state: { allowed: policy_allowed, reason: policy_reason },
    autonomy_mode,
    last_run: null,
    rank: 0,
  };
}

function jobCardFromApproval(item: { execution_id: string; created_at: string | null; plan_goal: string | null }): JobCard {
  return {
    job_id: item.execution_id,
    command: item.plan_goal ?? "Approval pending",
    confidence: { score: 0, band: "LOW", action: "PROPOSE_FOR_APPROVAL" },
    regression: { regressed: false },
    policy_state: { allowed: false, reason: "APPROVAL_REQUIRED" },
    autonomy_mode: "APPROVAL_GATED_AUTONOMY",
    last_run: { status: "paused", exit_code: 4, at: item.created_at },
    rank: 0,
  };
}

function jobCardFromRegistry(job: { job_id: string; command: string; mode: string }): JobCard {
  const threadId = (process.env.THREAD_ID || "local_test_001").trim();
  const baseUrl = String(process.env.NOTION_API_BASE || "http://localhost:8787").trim() || "http://localhost:8787";
  const at = new Date(process.env.SMOKE_FIXED_NOW_ISO || nowIso());
  const autonomyMode = job.mode;
  const env: NodeJS.ProcessEnv = { ...process.env, AUTONOMY_MODE: autonomyMode };

  // Build plan, simulate policy, then score (pure in-memory)
  let plan: any;
  try {
    plan = buildPlanForCommand(job.command, threadId, baseUrl);
  } catch {
    // If we cannot build deterministically, list as proposal-only placeholder.
    return {
      job_id: job.job_id,
      command: job.command,
      confidence: { score: 0, band: "LOW", action: "HUMAN_REVIEW_REQUIRED" },
      regression: { regressed: false },
      policy_state: { allowed: false, reason: "PROPOSE_ONLY" },
      autonomy_mode: autonomyMode,
      last_run: null,
      rank: 0,
    };
  }

  const sim = simulatePolicy({ plan, command: job.command, env, at, autonomy_mode: autonomyMode, approval: false });
  const policy_state = policyReasonFromSim(sim);

  const requiredCaps = Array.isArray(plan?.required_capabilities)
    ? plan.required_capabilities.filter((c: any) => typeof c === "string")
    : [];
  const capResolution = resolveCapabilityProviders(requiredCaps);

  const features = extractScoreFeatures({
    plan,
    policy_simulation: sim,
    capabilities_resolved: capResolution.capabilities_resolved,
    unresolved_capabilities: capResolution.unresolved,
    policy_env: env,
  });

  const scored = scorePolicy({
    target: job.command,
    evaluated_at: at.toISOString(),
    policy_simulation: { would_run: sim.would_run, decision: sim.decision === "ALLOWED" ? "ELIGIBLE" : sim.decision, reasons: (sim as any).reasons },
    features,
    obs: undefined,
  });

  return {
    job_id: job.job_id,
    command: job.command,
    confidence: {
      score: scored.confidence.score,
      band: scored.confidence.band,
      action: scored.confidence.action,
    },
    regression: { regressed: false },
    policy_state,
    autonomy_mode: autonomyMode,
    last_run: null,
    rank: 0,
  };
}

function parseOperatorCommand(command: string):
  | { kind: "OperatorQueue" }
  | { kind: "OperatorJob"; job_id: string }
  | { kind: "OperatorStats" }
  | null {
  const trimmed = command.trim();
  const mQueue = trimmed.match(/^\/operator\s+queue\s*$/i);
  if (mQueue) return { kind: "OperatorQueue" };
  const mJob = trimmed.match(/^\/operator\s+job\s+(\S+)\s*$/i);
  if (mJob) return { kind: "OperatorJob", job_id: mJob[1]! };
  const mStats = trimmed.match(/^\/operator\s+stats\s*$/i);
  if (mStats) return { kind: "OperatorStats" };
  return null;
}

(async () => {
  try {
    const raw = getArgCommand();
    {
      const threadId = (process.env.THREAD_ID || "local_test_001").trim();
      const now_iso = fixedNowIso();
      const denied = enforceCliCredits({ now_iso, threadId, command: raw, domain_id: null });
      if (denied) {
        console.log(JSON.stringify(denied, null, 0));
        process.exitCode = 1;
        return;
      }
    }
    const parsed = parseOperatorCommand(raw);
    if (!parsed) {
      throw new Error("Usage: /operator queue | /operator job <job_id> | /operator stats");
    }

    if (parsed.kind === "OperatorQueue") {
      const checks = listConfidenceChecks().map(jobCardFromConfidenceCheck).filter(Boolean) as JobCard[];
      const approvals = listApprovalsAwaiting().map(jobCardFromApproval);
      const jobs = listJobsRegistry().map(jobCardFromRegistry);

      const ranked = rankJobs([...checks, ...approvals, ...jobs]);

      console.log(
        JSON.stringify(
          {
            kind: "OperatorQueue",
            generated_at: nowIso(),
            jobs: ranked,
          },
          null,
          2
        )
      );
      process.exitCode = 0;
      return;
    }

    if (parsed.kind === "OperatorStats") {
      const checks = listConfidenceChecks();
      const approvals = listApprovalsAwaiting();
      const regressed = checks.filter((x) => Boolean((x.data as any)?.regression?.regressed)).length;
      const out = {
        kind: "OperatorStats",
        generated_at: nowIso(),
        approvals_awaiting: approvals.length,
        regressions: regressed,
      };
      console.log(JSON.stringify(out, null, 2));
      process.exitCode = 0;
      return;
    }

    // OperatorJob: minimal drill-down (read-only)
    const out = {
      kind: "OperatorJob",
      job_id: parsed.job_id,
      generated_at: nowIso(),
      note: "Not implemented in Tier-17 smoke vectors",
    };
    console.log(JSON.stringify(out, null, 2));
    process.exitCode = 0;
  } catch (err: any) {
    process.exitCode = 1;
    console.error(err?.message ? String(err.message) : String(err));
  }
})();
