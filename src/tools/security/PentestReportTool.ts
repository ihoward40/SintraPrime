// src/tools/security/PentestReportTool.ts
// Compiles all security findings from the ReceiptLedger into a structured report.

import { Tool } from "../../types/index.js";
import { ReceiptLedger } from "../../audit/receiptLedger.js";
import * as fs from "fs";
import * as path from "path";

export interface PentestReportArgs {
  engagementId: string;    // Unique ID for this pentest engagement
  startTime: string;       // ISO 8601 timestamp
  endTime: string;         // ISO 8601 timestamp
  targetScope: string[];   // List of targets in scope
  outputFormat?: "markdown" | "json";
}

export interface PentestFinding {
  id: string;
  type: string;
  severity: "CRITICAL" | "HIGH" | "MEDIUM" | "LOW" | "INFO";
  host: string;
  port: number;
  service: string;
  version: string;
  timestamp: string;
  receiptId: string;
}

export class PentestReportTool implements Tool {
  public readonly name = "pentest_report_generate";
  public readonly description =
    "Compiles all security findings from the ReceiptLedger for a given time " +
    "range into a structured penetration testing report in Markdown or JSON format.";

  constructor(private readonly receiptLedger: ReceiptLedger) {}

  async execute(args: PentestReportArgs): Promise<{ reportPath: string; summary: any }> {
    const receipts = this.receiptLedger.getReceiptsInRange(args.startTime, args.endTime);

    // Filter to security-related receipts only.
    const securityReceipts = receipts.filter(
      (r) =>
        r.actor.startsWith("agent:sentinel-guard-agent") ||
        r.action.startsWith("tool.nmap") ||
        r.action.startsWith("tool.metasploit") ||
        r.action.startsWith("tool.sqlmap") ||
        r.action.startsWith("tool.nikto") ||
        r.action.startsWith("tool.osint")
    );

    const findings = this.extractFindings(securityReceipts);
    const report = this.buildReport(args, findings);

    const outputFormat = args.outputFormat || "markdown";
    const fileName = `pentest_report_${args.engagementId}_${Date.now()}.${
      outputFormat === "markdown" ? "md" : "json"
    }`;
    const outputPath = path.join(process.cwd(), "reports", fileName);

    fs.mkdirSync(path.dirname(outputPath), { recursive: true });
    fs.writeFileSync(
      outputPath,
      outputFormat === "markdown"
        ? this.toMarkdown(report)
        : JSON.stringify(report, null, 2)
    );

    return {
      reportPath: outputPath,
      summary: {
        engagementId: args.engagementId,
        totalFindings: findings.length,
        critical: findings.filter((f) => f.severity === "CRITICAL").length,
        high: findings.filter((f) => f.severity === "HIGH").length,
        medium: findings.filter((f) => f.severity === "MEDIUM").length,
        low: findings.filter((f) => f.severity === "LOW").length,
        receiptCount: securityReceipts.length,
        chainValid: this.receiptLedger.verifyChain(),
      },
    };
  }

  private extractFindings(receipts: any[]): PentestFinding[] {
    const findings: PentestFinding[] = [];
    for (const receipt of receipts) {
      if (receipt.action === "tool.nmap_scan" && receipt.result?.findings) {
        for (const host of receipt.result.findings) {
          for (const port of host.openPorts || []) {
            findings.push({
              id: `finding-${receipt.id}-${port.port}`,
              type: "OPEN_PORT",
              severity: this.assessPortSeverity(port),
              host: host.host,
              port: port.port,
              service: port.service,
              version: port.version,
              timestamp: receipt.timestamp,
              receiptId: receipt.id,
            });
          }
        }
      }
    }
    return findings;
  }

  private assessPortSeverity(
    port: any
  ): "CRITICAL" | "HIGH" | "MEDIUM" | "LOW" | "INFO" {
    const highRiskPorts = [21, 23, 445, 1433, 3306, 3389, 5432];
    const mediumRiskPorts = [22, 25, 110, 143, 8080, 8443];
    if (highRiskPorts.includes(port.port)) return "HIGH";
    if (mediumRiskPorts.includes(port.port)) return "MEDIUM";
    return "LOW";
  }

  private buildReport(args: PentestReportArgs, findings: PentestFinding[]): any {
    return {
      metadata: {
        engagementId: args.engagementId,
        generatedAt: new Date().toISOString(),
        period: { start: args.startTime, end: args.endTime },
        scope: args.targetScope,
        system: "SintraPrime SentinelGuard v2.0",
      },
      executiveSummary: {
        totalFindings: findings.length,
        bySeverity: {
          CRITICAL: findings.filter((f) => f.severity === "CRITICAL").length,
          HIGH: findings.filter((f) => f.severity === "HIGH").length,
          MEDIUM: findings.filter((f) => f.severity === "MEDIUM").length,
          LOW: findings.filter((f) => f.severity === "LOW").length,
        },
      },
      findings,
    };
  }

  private toMarkdown(report: any): string {
    const { metadata, executiveSummary, findings } = report;
    let md = `# Penetration Test Report\n\n`;
    md += `**Engagement ID:** ${metadata.engagementId}\n`;
    md += `**Generated:** ${metadata.generatedAt}\n`;
    md += `**System:** ${metadata.system}\n`;
    md += `**Period:** ${metadata.period.start} to ${metadata.period.end}\n`;
    md += `**Scope:** ${metadata.scope.join(", ")}\n\n`;
    md += `## Executive Summary\n\n`;
    md += `| Severity | Count |\n| :--- | :--- |\n`;
    for (const [sev, count] of Object.entries(executiveSummary.bySeverity)) {
      md += `| ${sev} | ${count} |\n`;
    }
    md += `\n**Total Findings:** ${executiveSummary.totalFindings}\n\n`;
    md += `## Detailed Findings\n\n`;
    for (const f of findings) {
      md += `### ${f.type}: ${f.host}:${f.port} (${f.severity})\n\n`;
      md += `- **Service:** ${f.service} ${f.version}\n`;
      md += `- **Timestamp:** ${f.timestamp}\n`;
      md += `- **Receipt ID:** ${f.receiptId}\n\n`;
    }
    return md;
  }
}
